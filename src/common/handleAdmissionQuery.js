const tuyenSinhCollection = require("../app/models/diemchuan");
const { OpenAI } = require("openai");
require("dotenv").config();

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

const classifyAndExtractUserQuery = async (userQuery) => {
  const systemPrompt = `
    B·∫°n l√† h·ªá th·ªëng ph√¢n lo·∫°i v√† tr√≠ch xu·∫•t th√¥ng tin t·ª´ c√¢u h·ªèi tuy·ªÉn sinh c·ªßa th√≠ sinh.
    1. N·∫øu c√¢u h·ªèi l√† lo·∫°i "c·ªông ƒëi·ªÉm h·ªçc b·∫°" ho·∫∑c "t√≠nh ƒëi·ªÉm ∆∞u ti√™n h·ªçc b·∫°" ho·∫∑c "t·ªïng ƒëi·ªÉm th∆∞·ªüng", "t·ªïng ƒëi·ªÉm ∆∞u ti√™n", d·ª±a v√†o th√¥ng tin sau: 
    Region: KV1 (mi·ªÅn n√∫i, v√πng n√∫i, ven bi·ªÉn, h·∫£i ƒë·∫£o, bi√™n gi·ªõi, c√°c th√¥n ƒë·∫∑c bi·ªát kh√≥ khƒÉn, x√£ an to√†n khu, ...), KV2-NT (khu v·ª±c n√¥ng th√¥n kh√¥ng thu·ªôc KV1), KV2 (c√°c th·ªã x√£, th√†nh ph·ªë tr·ª±c thu·ªôc t·ªânh; c√°c th·ªã x√£, huy·ªán ngo·∫°i th√†nh ), KV3 (qu·∫≠n n·ªôi th√†nh, th√†nh ph·ªë).
    Policy: UT1 ho·∫∑c UT2
    h√£y xu·∫•t ra JSON sau (n·∫øu c√≥):
    {
      "query_type": "tinh_diem_hoc_ba_uutien",
      "original_score": <s·ªë ƒëi·ªÉm thi>,
      "ielts_score": <ƒëi·ªÉm IELTS>,
      "good_grade_years": <s·ªë nƒÉm h·ªçc sinh gi·ªèi>,
      "region": <khu v·ª±c ∆∞u ti√™n nh∆∞ KV1, KV2, KV2-NT, KV3>,
      "policy": <UT1, UT2>
    }
    2. N·∫øu c√¢u h·ªèi l√† nh∆∞:
    "em ƒë∆∞·ª£c XX ƒëi·ªÉm h·ªçc b·∫° c√≥ ƒë·ªó v√†o ng√†nh ... kh√¥ng?", 
    "em ƒë∆∞·ª£c XX ƒëi·ªÉm thi THPT c√≥ ƒë·ªó v√†o ng√†nh ... kh√¥ng?", 
    "XX ƒëi·ªÉm thpt ƒë·ªó g√¨ ko ·∫° ?"
    h√£y xu·∫•t ra JSON sau:
    {
      "query_type": "du_doan_do_nganh",
      "field": "<t√™n ng√†nh>",
      "score_type": "<thpt or h·ªçc b·∫°>",
      "score": <s·ªë ƒëi·ªÉm c·ªßa th√≠ sinh>
    }
    3. N·∫øu kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c, tr·∫£ v·ªÅ:
    {
      "query_type": "unknown"
    }
    Ch·ªâ xu·∫•t ra n·ªôi dung JSON h·ª£p l·ªá (b·∫Øt ƒë·∫ßu b·∫±ng '{', k·∫øt th√∫c b·∫±ng '}'), kh√¥ng th√™m vƒÉn b·∫£n th·ª´a, kh√¥ng c√≥ b√¨nh lu·∫≠n.
  `;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userQuery },
      ],
    });

    const content = response.choices[0].message.content;
    // console.log("content", content);

    try {
      const parsed = JSON.parse(content);
      // console.log(content);
      // console.log(parsed);

      if (typeof parsed === "object" && parsed !== null) {
        const query_type = parsed.query_type || "unknown";
        if (query_type === "du_doan_do_nganh") {
          return {
            query_type,
            extracted: {
              field: parsed.field || null,
              score_type: parsed.score_type || null,
              score: parsed.score,
            },
          };
        } else if (query_type === "tinh_diem_hoc_ba_uutien") {
          return {
            query_type,
            extracted: {
              original_score: parsed.original_score,
              ielts_score: parsed.ielts_score || null,
              good_grade_years: parsed.good_grade_years || null,
              region: parsed.region || null,
              policy: parsed.policy || null,
            },
          };
        }
      }
    } catch (error) {
      throw new Error(`‚ùå JSON decode error: ${error.message}`);
    }
    return { query_type: "unknown", extracted: {} };
  } catch (error) {
    console.error(`OpenAI API error: ${error.message}`);
    return { query_type: "unknown", extracted: {} };
  }
};

// T·∫£i d·ªØ li·ªáu ƒëi·ªÉm chu·∫©n t·ª´ tuyenSinhCollection
async function loadScoreData() {
  try {
    const data = await tuyenSinhCollection.find({}, { projection: { _id: 0 } });
    return data;
  } catch (error) {
    console.error(`Error loading score data: ${error.message}`);
    return [];
  }
}

// T√¨m ki·∫øm ƒëi·ªÉm chu·∫©n
function findMatchingScores(data, scoreType, field, score) {
  scoreType = scoreType.toLowerCase();
  if (field) {
    const filtered = data.filter(
      (item) =>
        item.ScoreType.toLowerCase() === scoreType &&
        item.Field.toLowerCase().includes(field.toLowerCase())
    );
    const results = [];
    for (const year of [2023, 2024, 2025]) {
      const rows = filtered.filter((item) => item.Year === year);
      for (const row of rows) {
        const passingScore = parseFloat(row.Score);
        const status =
          score >= passingScore ? "‚úîÔ∏è ƒê·ªß ƒëi·ªÉm" : "‚ùå Kh√¥ng ƒë·ªß ƒëi·ªÉm";
        results.push({
          Year: year,
          Field: row.Field,
          Score: passingScore,
          Status: status,
        });
      }
    }
    return results;
  } else {
    const filtered = data.filter(
      (item) =>
        item.ScoreType.toLowerCase() === scoreType &&
        [2024, 2025].includes(item.Year) &&
        item.Score <= score
    );
    return filtered.map((item) => ({
      Field: item.Field,
      Year: item.Year,
      Score: item.Score,
    }));
  }
}

// X·ª≠ l√Ω c√¢u h·ªèi ng∆∞·ªùi d√πng
async function handleAdmissionQuery(userInput) {
  const parsed = await classifyAndExtractUserQuery(userInput);
  const query_type = parsed.query_type;
  let generatedAnswer;

  if (query_type === "du_doan_do_nganh") {
    const { score, field, score_type } = parsed.extracted;
    const data = await loadScoreData();

    if (score !== null && score !== undefined) {
      if (!score_type) {
        const warning_msg =
          "‚ùó Vui l√≤ng nh·∫≠p l·∫°i c√¢u h·ªèi k√®m theo lo·∫°i ƒëi·ªÉm (THPT ho·∫∑c h·ªçc b·∫°). " +
          "B·∫°n c√≥ th·ªÉ h·ªèi: *Em ƒë∆∞·ª£c 25 ƒëi·ªÉm THPT, li·ªáu c√≥ ƒë·ªó ng√†nh C√¥ng ngh·ªá th√¥ng tin kh√¥ng ·∫°?*";
        // console.log(warning_msg);
        generatedAnswer = warning_msg;
      } else {
        if (field) {
          // console.log(
          //   `üîç Tra c·ª©u ƒëi·ªÉm ng√†nh **${field}**, lo·∫°i ƒëi·ªÉm **${score_type}**, ƒëi·ªÉm c·ªßa b·∫°n: **${score}**`
          // );
          const results = findMatchingScores(data, score_type, field, score);
          if (results.length) {
            const result_texts = results.map(
              (item) =>
                `- NƒÉm ${item.Year} | Ng√†nh: **${item.Field}** | ƒêi·ªÉm chu·∫©n: **${item.Score}** ‚Üí ${item.Status}`
            );
            generatedAnswer = result_texts.join("\n");
          } else {
            const warning_msg =
              "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y th√¥ng tin ƒëi·ªÉm chu·∫©n ph√π h·ª£p cho ng√†nh ƒë√£ nh·∫≠p.";
            // console.log(warning_msg);
            generatedAnswer = warning_msg;
          }
        } else {
          // console.log(
          //   `üîç ƒêang tra c·ª©u c√°c ng√†nh ph√π h·ª£p v·ªõi ƒëi·ªÉm **${score}**, lo·∫°i ƒëi·ªÉm **${score_type}**...`
          // );
          const matches = findMatchingScores(data, score_type, null, score);
          if (matches.length) {
            // console.log("### ‚úÖ C√°c ng√†nh b·∫°n c√≥ th·ªÉ ƒë·ªß ƒëi·ªÅu ki·ªán x√©t tuy·ªÉn:");
            // console.log(matches);
            generatedAnswer =
              "‚úÖ M·ªôt s·ªë ng√†nh b·∫°n c√≥ th·ªÉ ƒë·ªß ƒëi·ªÅu ki·ªán x√©t tuy·ªÉn:\n" +
              matches
                .map(
                  (row) => `- ${row.Field} (${row.Score} ƒëi·ªÉm, nƒÉm ${row.Year})`
                )
                .join("\n");
          } else {
            const warning_msg =
              "‚ö†Ô∏è Kh√¥ng c√≥ ng√†nh n√†o ph√π h·ª£p v·ªõi m·ª©c ƒëi·ªÉm n√†y.";
            // console.log(warning_msg);
            generatedAnswer = warning_msg;
          }
        }
      }
    } else {
      const warning_msg =
        "‚ö†Ô∏è Kh√¥ng ph√°t hi·ªán ƒëi·ªÉm trong c√¢u h·ªèi. Vui l√≤ng nh·∫≠p ƒëi·ªÉm ƒë·ªÉ ti·∫øp t·ª•c t∆∞ v·∫•n.";
      // console.log(warning_msg);
      generatedAnswer = warning_msg;
    }
  } else if (query_type === "tinh_diem_hoc_ba_uutien") {
    const { original_score, ielts_score, good_grade_years, region, policy } =
      parsed.extracted;
    let bonus = 0.0;
    let priority_region = 0.0;
    let priority_policy = 0.0;
    const max_score = 30.0;

    // T√≠nh ƒëi·ªÉm c·ªông IELTS
    try {
      const ielts = ielts_score ? parseFloat(ielts_score) : null;
      if (ielts) {
        if (ielts >= 4.5 && ielts < 5.0) bonus += 0.75;
        else if (ielts >= 5.0 && ielts < 6.0) bonus += 1.0;
        else if (ielts >= 6.0 && ielts < 7.0) bonus += 1.25;
        else if (ielts >= 7.0) bonus += 1.5;
      }
    } catch {
      // B·ªè qua l·ªói
    }

    // T√≠nh ƒëi·ªÉm c·ªông h·ªçc sinh gi·ªèi
    try {
      const good_years = good_grade_years ? parseInt(good_grade_years) : null;
      if (good_years === 1) bonus += 0.3;
      else if (good_years === 2) bonus += 0.6;
      else if (good_years >= 3) bonus += 0.9;
    } catch {
      // B·ªè qua l·ªói
    }

    // T√≠nh ƒëi·ªÉm ∆∞u ti√™n khu v·ª±c
    const regionUpper = region ? String(region).trim().toUpperCase() : "";
    if (regionUpper === "KV1") priority_region = 0.75;
    else if (regionUpper === "KV2-NT") priority_region = 0.5;
    else if (regionUpper === "KV2") priority_region = 0.25;
    else if (regionUpper === "KV3") priority_region = 0.0;

    // T√≠nh ƒëi·ªÉm ∆∞u ti√™n ƒë·ªëi t∆∞·ª£ng
    const policyUpper = policy ? String(policy).trim().toUpperCase() : "";
    if (policyUpper === "UT1") priority_policy = 2.0;
    else if (policyUpper === "UT2") priority_policy = 1.0;

    const total_priority = priority_region + priority_policy;

    // T√≠nh to√°n cu·ªëi c√πng
    if (!original_score) {
      const total_added = (bonus + total_priority).toFixed(2);
      generatedAnswer =
        `‚úÖ B·∫°n ƒë∆∞·ª£c c·ªông t·ªïng c·ªông **${total_added} ƒëi·ªÉm**.\n\n` +
        `- ƒêi·ªÉm c·ªông th∆∞·ªüng: **${bonus}**\n` +
        `- ƒêi·ªÉm ∆∞u ti√™n khu v·ª±c: **${priority_region}**\n` +
        `- ƒêi·ªÉm ∆∞u ti√™n ƒë·ªëi t∆∞·ª£ng: **${priority_policy}**\n\n` +
        `‚û°Ô∏è B·∫°n c√≥ th·ªÉ c·ªông th√™m v√†o ƒëi·ªÉm h·ªçc b·∫° khi x√©t tuy·ªÉn theo ph∆∞∆°ng th·ª©c h·ªçc b·∫° k·∫øt h·ª£p.`;
    } else {
      try {
        const originalScore = parseFloat(original_score);
        const combined_score = originalScore + bonus;
        let final_score, adjusted_total_priority;

        if (combined_score >= max_score) {
          final_score = max_score;
          adjusted_total_priority = 0;
        } else if (combined_score >= 22.5) {
          adjusted_total_priority = (
            ((max_score - combined_score) / 7.5) *
            total_priority
          ).toFixed(2);
          final_score = (
            combined_score + parseFloat(adjusted_total_priority)
          ).toFixed(2);
        } else {
          adjusted_total_priority = total_priority;
          final_score = (combined_score + total_priority).toFixed(2);
        }

        generatedAnswer =
          `‚úÖ ƒêi·ªÉm x√©t tuy·ªÉn c·ªßa b·∫°n sau khi c·ªông:\n` +
          `- ƒêi·ªÉm h·ªçc b·∫° ban ƒë·∫ßu: **${originalScore}**\n` +
          `- ƒêi·ªÉm c·ªông th∆∞·ªüng: **${bonus}**\n` +
          `- ƒêi·ªÉm ∆∞u ti√™n khu v·ª±c: **${priority_region}**\n` +
          `- ƒêi·ªÉm ∆∞u ti√™n ƒë·ªëi t∆∞·ª£ng: **${priority_policy}**\n` +
          `- T·ªïng ƒëi·ªÉm ∆∞u ti√™n ƒë∆∞·ª£c c·ªông: **${adjusted_total_priority}**\n\n` +
          `‚û°Ô∏è **T·ªïng ƒëi·ªÉm x√©t tuy·ªÉn: ${final_score}**`;
      } catch {
        generatedAnswer =
          "‚ö†Ô∏è L·ªói khi t√≠nh ƒëi·ªÉm x√©t tuy·ªÉn. Vui l√≤ng ki·ªÉm tra l·∫°i ƒëi·ªÉm ƒë·∫ßu v√†o.";
      }
    }
  } else {
    generatedAnswer = null;
  }

  return generatedAnswer;
}

module.exports = {
  classifyAndExtractUserQuery,
  findMatchingScores,
  handleAdmissionQuery,
};
